%{
package retroscope.rql;
import retroscope.rql.syntaxtree.*;
import java.util.HashMap;

%}
// D:\Dropbox\school\UNF\COP6xxx\language\jacc D:\Dropbox\ubuntu_vms_share\retroscope-lib\rql-server\src\main\java\retroscope\rql\rql.jacc -t
%class rqlParser
%interface mTokens
%next              	nextToken()
%get               	lexer.token
%semantic Object : 	lexer.semanticValue

%token <String>  IDENTIFIER
%token <Integer> INTEGER_LITERAL 
%token <Double>  FLOAT_LITERAL
%token <String>	 STRING_LITERAL
%token <String> '{' '(' '[' ']' ')' '}' ';' ',' '='  '<' '+' '-' '*' '.' '!'
%token <String> EXPLAIN SELECT
%token <String> BETWEEN AFTER BEFORE
%token <String> COUNT SUM
%token <String> FROM WHEN AT ON TO
%token <String> NODES ALL_NODES TIME SAME_NODE
%token <String> TRUE FALSE AND OR NEQ EQ GEQ LEQ

/* Precedence and associativity of operators */
//%right ASSIGN
%left '!'
%left AND
%left OR
%left LINK
%left '=' EQ NEQ
%left '<' '>' LEQ GEQ
%left '+' '-'
%left '*' '/' '%'


%type <Expression>  		Expression AtTimeExtended
%type <IdentifierList>  	IdentifierList
%type <When>              	When
%type <AtNodes>             AtNodes
%type <OnTime>             	OnTime
%type <Param>             	Param
%type <ParamList>           ParamList
%type <Aggregator>          Aggregator
%type <Query>               Query
%type <QueryEnd>            QueryEnd
%type <ExpressionList>      ExpressionList


/* start symbol */
%start Statements

%%

Statements 			: 	Statement Statements  									        {}
					|                                                                   {}
					;

Statement           :   Query ';'                                                       {$1.execute();}
                    |   EXPLAIN Query ';'                                               {$2.explain();}
                    |   Expression ';'                                                  {$$ = new EvalExpression($1);}
                    ;

Query               :   SELECT ParamList FROM IdentifierList QueryEnd                   {$$ = new Query($2, $4, $5, currentEnv);}
                    ;

QueryEnd            :   When TimeSearch AtNodes OnTime                                  {$$ = new QueryEnd($1, $2 $3, $4);}
                    ;

TimeSearch          :   BETWEEN '(' Expression ',' Expression ')' LINK Expression       {$$ = new TimeSearch(TimeSearch.BETWEEN, $3, $5, $8);}
                    |   BEFORE Expression                                               {$$ = new TimeSearch(TimeSearch.BEFORE, $2);}
                    |   AFTER Expression                                                {$$ = new TimeSearch(TimeSearch.AFTERN, $2);}
                    |
                    ;

When                :   WHEN Expression                                                 {$$ = new When($2);}
                    |                                                                   {$$ = null;}
                    ;


AtNodes             :   AT NODES IdentifierList                                         {$$ = new AtNodes($3);}
                    |   AT ALL_NODES                                                    {$$ = new AtNodes();}
                    |                                                                   {$$ = null;}
                    ;

OnTime              :   ON TIME Expression AtTimeExtended                               {$$ = new OnTime($3, $4);}
                    |                                                                   {$$ = null;}
                    ;

AtTimeExtended      :   TO Expression                                                   {$$ = $2;}
                    |                                                                   {$$ = null;}
                    ;

ParamList           :   Param ',' ParamList                                             {$$ = new ParamList($1, $3);}
                    |   Param                                                           {$$ = new ParamList($1);}
                    ;

Param               :   IDENTIFIER                                                      {$$ = new Param($1);}
                    |   IDENTIFIER '.' IDENTIFIER                                       {$$ = new Param($1, $3);}
                    |   Aggregator '(' IDENTIFIER ')'                                   {$$ = new Param($3);}
                    |   Aggregator '(' IDENTIFIER '.' IDENTIFIER ')'                    {$$ = new Param($3, $5);}
                    ;

Aggregator          :   COUNT                                                           {$$ = new Aggregator(AggregatorType.COUNT);}
                    |   SUM                                                             {$$ = new Aggregator(AggregatorType.SUM);}
                    ;

IdentifierList      :   IDENTIFIER ',' IdentifierList                                   {$$ = new IdentifierList($1, $3);}
                    |   IDENTIFIER                                                      {$$ = new IdentifierList($1);}
                    ;

Expression			:	'-' Expression											        {$$ = new Minus(currentEnv, $2);}
					|	Expression '+' Expression									    {$$ = new Plus(currentEnv, $1, $3);}
					|	Expression '-' Expression										{$$ = new Minus(currentEnv, $1, $3);}
					|	Expression '/' Expression										{$$ = new Divide(currentEnv, $1, $3);}
					| 	Expression '*' Expression										{$$ = new Multiply(currentEnv, $1, $3);}
					| 	Expression '%' Expression										{$$ = new Mod(currentEnv, $1, $3);}
					|	'(' Expression ')'											    {$$ = $2;}
					| 	Expression '=' Expression										{$$ = new EQExpression(currentEnv, $1, $3);}
					|	Expression EQ Expression										{$$ = new EQExpression(currentEnv, $1, $3);}
					|	Expression NEQ Expression										{$$ = new NEQExpression(currentEnv, $1, $3);}
					|	Expression LEQ Expression										{$$ = new LEQExpression(currentEnv, $1, $3);}
					|	Expression GEQ Expression										{$$ = new GEQExpression(currentEnv, $1, $3);}
					|	Expression '<' Expression										{$$ = new LessThanExpression(currentEnv, $1, $3);}
					|	Expression '>' Expression										{$$ = new GreaterThanExpression(currentEnv, $1, $3);}
					| 	'!' Expression											        {$$ = new NotExpression(currentEnv, $2);}
					|	Expression AND Expression										{$$ = new And(currentEnv, $1, $3);}
					|	Expression OR Expression										{$$ = new Or(currentEnv, $1, $3);}
					|   Expression LINK Expression                                      {$$ = new LinkConditionalExpression(currentEnv, $1, $3);}
					|   Expression LINK SAME_NODE                                       {$$ = new LinkConditionalExpression(currentEnv, $1);}
					|   IDENTIFIER '(' ExpressionList ')'                               {$$ = new FuncCall(currentEnv, $1, $3);}
					|	IDENTIFIER											            {$$ = new Variable($1, currentEnv, true);}
					|	IDENTIFIER '.' IDENTIFIER							            {$$ = new Variable($1, $3, currentEnv, true);}
					|	IDENTIFIER '.' IDENTIFIER ':' IDENTIFIER			            {$$ = new Variable($1, $3, $5, currentEnv, true);}
					|	IDENTIFIER ':' IDENTIFIER			                            {$$ = new Variable("", $1, $3, currentEnv, true);}
					| 	INTEGER_LITERAL											        {$$ = new IntegerLiteral(currentEnv, $1);}
					|	FLOAT_LITERAL											        {$$ = new FloatLiteral(currentEnv, $1);}
					|	STRING_LITERAL											        {$$ = new StringLiteral(currentEnv, $1);}
					|	TRUE											                {$$ = new IntegerLiteral(currentEnv, 1);}
					|	FALSE											                {$$ = new IntegerLiteral(currentEnv, 0);}
					;

ExpressionList      :   Expression ',' ExpressionList                                   {$$ = new ExpressionList($1, $3);}
                    |   Expression                                                      {$$ = new ExpressionList($1);}
                    |                                                                   {$$ = new ExpressionList();}
                    ;

%%


/* code in the parser class*/

private Scanner lexer;
private RQLEnvironment currentEnv;

/* constructor registering a lexer for lang */
public rqlParser(Scanner lexer){
    this.lexer=lexer;
}

/* implementation of the nextToken() using lexer.yylex() that throws an
exception 
*/

private int nextToken(){
      try{ 
          return lexer.yylex();
       }catch(java.io.IOException e){System.out.println("IO exception from lexer!");e.printStackTrace();}
       return 0;
}	


private void yyerror(String msg) { 
    System.out.println(
      "ERROR "+ msg + "\n" +
      " at line   " +(lexer.line() + 1) + "\n" + 
      " at column " +(lexer.column() + 1) + "\n" + 
      " with token <<" + lexer.semanticValue + ">>"); }


public RQLEnvironment getEnvironment() {
    return currentEnv;
}

public rqlParser setEnvironment(RQLEnvironment currentEnv) {
    this.currentEnv = currentEnv;
    return this;
}

